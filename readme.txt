Содержание симулятора для общего случая:
Matrics_Simulator_general_case.m - файл симулятора, реализованного с помощью матриц
Cycle_Simulator_general_case.m - файл симулятора, реализованного с помощью циклов (аналог
				 симулятора на Си)
zernike_8_deriv.m - функция, которая считает производные ВФ 
                    по заданным коэффициентам Цернике
Hartmannograms - папка, в которую идет запись гартманнограм 
                 (должна быть создана до записи)
Files_txt - папка, в которую идет запись текстовых (.txt) файлов 
            для обработки 

Входными данными для симулятора служат параметры ДШГ: 
размер питча, пикселя, фокусное расстояние растра, длина волны принимаего излучения,
кол-во пикселей сенсора по осям x и y, битность камеры.
Добавлен Cut_flag:
	Для расчета патернов интенсивности в крайних субапертурах заданное поле пикселей
дополняется до такого количества, чтобы в него помещалось целое количество субапертур
(высчитывается по кол-ву пикселей в одной микролинзе). 
	Если Cut_flag == 1, пиксели симметрично обрезаются по краям, сохраняя исходное
кол-во пикселей сенсора по осям x и y. Если Cut_flag == 0, выходная гартманнограма 
состоит из бОльшего кол-ва пикселей.

Выходные данные симулятора (гартманнограма плоского референса, текстовый
референс, обрабатываемая гартманнограма и обрабатываемый текстовый файл)
получены по заданным коэффициентам Цернике (первые 8 по Вьянту).

Идея: 
1) Программа в каждой микролинзе формирует матрицу интенсивности, 
соответсвующую дифракционной картине на квадратном отверстии:
I(x,y) = (sinc(Pitch*x/Lambda/ML_focal))^2 * (sinc(Pitch*y/Lambda/ML_focal))^2
2) Далее находит знаение интенсивности в середине пикселя и конвертирует это представление
в цифровое (квантование по уровням битности);
3) По заданным коэффициентам Цернике с помощью функции zernike_8_deriv.m
рассчитывают производные ВФ по осям х и у. Смещение центра фокального пятна
вычисляется как: Shift = WF_deriv * ML_focal/ApertRad
4) Тогда матрица интенсивности рассчитывается след образом:
I(x,y) = (sinc(Pitch*(x-ShiftX)/Lambda/ML_focal))^2 * (sinc(Pitch*(y-ShiftY)/Lambda/ML_focal))^2

Проблемы в симуляторе:
	- от факта обрезания точность симулятора по матрицам не меняется, но крайние левый столбец 
субапертур и верхний WFS7 не берет к анализу. При задании дефокуса = 1 мкм у меня для 500 получилось
0.9899, для 2048 - 0.9904 (в WFS7.1);
	- я нашла причину изменения точности при переходе от циклов (и соотвественно симулятора на Си,
так как в циклах реализован его же алгоритм) к матрицам. 
	В циклах для некоторых субапертур из-за округлений дробных значений центров субапертур (в пикселях) 
получается 24 пикселя, а для некоторых 25 (при истинном 24,7). Обнаружилось это из-за получения разного 
количества пикселей в выхоной картинке (в циклах их меньше, поэтому там обрезание пикселей не симметрично) 
и далее при отладке (для некоторых субапертур 25ое значение предыдущей переписывает 1ое значение последующей субапертуры). 
	В матрицах таких округлений нет и я пока не знаю, как их реализовать. Для циклов при задании дефокуса = 1 мкм 
для 500 получилось 0.991, для 2048 - 0.9986 (в WFS7.1). Точности не так сильно различаются, если сравнить разность
полученного и заданного (для 500 - 0.0101 (матрицы) и 0.009 (циклы)).

